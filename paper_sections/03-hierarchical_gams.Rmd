---
output:
  pdf_document: default
  html_document: default
---

# What do we mean by hierarchical smooths?

Ecological data is often hierarchically structured, with observations occurring in groups (which may in turn may be grouped at higher levels). The smoothers we went over in section II allowed us to model global nonlinear relationships between our **x** and **y** variables. However, in many cases we want to fit a different functional relationship for each level of a grouping variable. In this section, we will cover the different ways to model inter-group variability in smooth curves, and how to fit the different models in mgcv.

When modelling hierarchical smooths in mgcv, there are three broad choices to make:

1. Should each the functional relationship between x and y for each group have its own smooth, or will a global smooth term suffice? 

2. Do all of the group-specific curves have similar smoothness to one another, or should each group have its own smoothness penalty?

3. Will the different smooth functions for each group have a similar shape to one another? That is, there a shared global average curve?



The combination of these three questions results in 5 possible models (figure *models*) beyond the null model of no functional relation between **x** and **y**:

1. A single common smooth function for all observations.

2. A single common smooth function plus group-level functions that are all similarly smooth to one another.

3. A single common smooth plus group-level functions that vary in smoothness from one another.

4. Group-specific smooth functions without an average trend, but with all functions being similarly smooth.

5. Group-specific functions that differ in smoothness. 


![](../figures/alternate_models.png)

We will discuss the trade-offs between different models and  guidelines about when each of these models is appropriate in section IV. The remainder of this section will focus on how to model each of these 5 models using `mgcv`. 

# Coding hierarchical GAMs in R

**EJP: Going with simulated data for the examples rather than real as it's a bit less messy, and lets us show true functions to compare with simulated.**

Each of these models can be coded straightforwardly in `mgcv`. We will use two example datasets to demonstrate how to code these models, one real and one simulated (see the appendix for code to generate these examples):

A. The CO2 dataset, available in R in the default *datasets* package. This data is from an experimental study by CITE of $CO_2$ uptake in grasses under varying concentrations of $CO_2$, measuring how concentration-uptake functions varied between plants from two locations (Mississippi and Quebec) and two temperature treatments (chilled and warm). A total of 12 plants were measured, and uptake measured at 7 concentration levels for each plant. Here we will focus on how to use these techniques to estimate inter-plant variation in functional responses. 

B. A hypothetical study of bird movement along a migration corridor. This dataset consists of records of numbers of observed locations of 100 tagged individuals each from six species of bird, at ten locations along a latitudinal gradient, with one observation taken every four weeks. Not every bird was observed at each time point, so counts vary randomly between location and week. The data set (bird_move) consists of the variables `count`, `latitude`, `week` and `species`. This example will allow us to demonstrate how to fit these models with interactions and with non-normal (count) data. 


## Model 1: a single global smooth term

 This is the typical GAM setup, with a single smooth term for each variable. Specifying the model is similar to specifying a `glm` in R. One-dimensional or isotropic multidimensional smooth terms are specified with a function named `s()`. The first arguments (given without names) are the terms to be smoothed over. The type of smooth to be used for the term is specified by writing `bs=<basis name>`, and the number of basis functions is specified by `k=<number of functions>`. The `s()` function will also take additional arguments, depending on the type of smooth. Both `bs` and `k` have default values; `bs` defaults to a thin-plate spline (`bs="tp"`) and `k` defaults to a value determined by the type of smoother (`k=10` by default for `bs="tp"`). See the documentation in `mgcv` for more details on specifying smooth terms, with `?mgcv::s` and `?mgcv::smooth.terms`. For a given `gam` model, you can have an arbitrary number of smooth terms, connected by putting `+` between each `s()` function. This is equivalent to including linear terms without interactions in a standard `glm` model. 

For our CO2 data set, we will use two basic smooth terms: a thin plate spline to model the average functional relationship between $CO_2$ concentration and uptake, and a simple random effect smoother for species to model species-specific intercepts. 

```{r co2_mod1, echo=TRUE,  fig.width=6, fig.height=3,message=F, warning=F, cache=TRUE}
library(mgcv)
library(ggplot2)

CO2_mod1 = gam(log(uptake) ~ s(log(conc),k=7,m=2, bs="tp")+s(Plant, k =12,  bs="re"), data= CO2,method="REML")

plot(CO2_mod1,page=1)


```

This shows how to fit the model, and shows the default plot for the model for `mgcv`. The plot has two panels: the first showing the estimated global functional relationship, and the second showing the estimated distribution of random effects for the plant-specific intercepts.

Note that we're actually modelling ln(uptake); this can be a useful approach when dealing with estimating multiple functional relationships as it means that functions that differ from each other by a multiplicative constant (so $f_1(x) = \alpha\cdot f_2(x)$ will differ by an additive constant when log-transformed (which can be estimated by simple random effects): $ln(f_1(x)) = ln(\alpha)+ ln(f_2(x))$. We have also ln-transformed concentration. Since the concentration-uptake relationship changes rapidly at low concentration values and slowly at higher values, estimating the relationship without log-transforming it can lead to a small estimated penalty value, and an overly wiggly function at higher concentration values.

Note also that we have also specified `method="REML"`. This tells `mgcv` to use Restricted Maximum Likelihood [CITE] to estimate model coefficients and penalty terms. We strongly recommend using either `method="REML"` or `method="ML"` (marginal likelihood) when fitting models, as the default `method="GCV.Cp"` is not as consistent at estimating smoothing penalties as the likelihood-based methods and tends to substantially undersmooth terms [CITE]. 

Here is how you could plot this to illustrate inter-plant variation in the functional response with estimated functional variability, plotting untransformed uptake and concentration to make the figure easier to comprehend. You can see the effect log-transforming concentration has on model fits; even though plants Mc1 -- Mc3 show a much flatter response in untransformed space, the same functional response fits relatively well after accounting for the random effect (a multiplicative difference between functional responses).

```{r co2_mod1_ggplot, echo=TRUE,  fig.width=6, fig.height=3,message=F, warning=F, cache=TRUE}
CO2_mod1_pred = predict(CO2_mod1,se.fit = T)
CO2$mod1 = CO2_mod1_pred$fit
CO2$mod1_se = CO2_mod1_pred$se.fit

ggplot(data=CO2, aes(x=conc, y= uptake, group=Plant))+
  facet_wrap(~Plant)+
  geom_point()+
  geom_line(aes(y=exp(mod1)))+
  geom_ribbon(aes(ymin=exp(mod1-2*mod1_se), ymax=exp(mod1+2*mod1_se)),alpha=0.5)
```



Global smooth models with interactions are also straightforward to model. For isotropic smooths such as thin-plate splines, extra terms can simply be added to the `s()` function. For non-isotropic smooths, we use the tensor product (`te()`) function. It is specified similarly to the `s()` function, but requires additional information to specify the types of basis and number of basis functions used for each marginal term. `bs` can be specified as a single value, in which case that basis is used for all marginal terms in the model. `k` can also be given as a single value, and works similar to `bs`. As with `s()`, the user can also give `te()` more options depending on the basis types used. For more information, consult `?mgcv::te`.

For our bird example, we will use one smooth term, a tensor product of latitude and week. We will use using a 10 basis function thin plate spline for the marginal latitude effects, and a 10 basis function cyclic cubic spline for the marginal week effect to account for the cyclic nature of weekly effects (we expect week 1 and week 52 to have very similar values). We will also assume the date (counts of individuals at each location in each week) follow a Poisson distribution. 

Note that the total number of basis functions used for a given smooth is the product of the marginal `k` values, so in this example the smooth would have 99 parameters (10*10, minus one to account for the presence of the global intercept). It will also have two smoothing parameters estimated; one for each marginal basis.

```{r bird_mod1, echo=TRUE,  fig.width=4, fig.height=4, message=F, warning=F, cache=T}
library(mgcv)
library(ggplot2)
library(tidyr)
library(viridis) #for color plotting

bird_move = read.csv("../data/bird_move.csv")

bird_mod1 = gam(count ~ te(week,latitude, bs= c("cc", "tp"), k=c(10,10)), 
                data= bird_move, method="REML", family= poisson)

plot(bird_mod1, page=1, scheme=2,rug = F)

```


This plot illustrates the average (log) abundance of all bird species at each latitude for each week, with yellow colours indicating more individuals and red colours fewer. This graph implies that these birds are starting at low latitudes in the winter then migrating to high latitudes from the 10th to 20th week, staying there for 15-20 weeks, then migrating back. However, this plot indicates a large amount of uncertainty in the timing of migration. The source of this variability is apparent when the migration timing of each species is plotted in conjunction with the model fit:



```{r bird_mod1_ggplot, echo=TRUE,  fig.width=8, fig.height=3, message=F, warning=F, cache=T}
bird_move$mod1 = predict(bird_mod1,type ="response")

bird_move_plot = gather(bird_move, key = model,value = value, count,mod1)

ggplot(data=bird_move_plot, aes(x=week, y=latitude, fill = value,color=value))+
  geom_tile(size=1)+
  facet_grid(model~species)+
  scale_fill_viridis("individuals")+
  scale_color_viridis("individuals")+
  scale_x_continuous(expand=c(0,0),breaks = c(1,26,52))+
  scale_y_continuous(expand=c(0,0), breaks=c(0,30,60))
```


Here the top row denotes the observed counts of each species (with color indicating relative abundance in that location in that week), and the bottom indicates the model fit. All six species show relatively precise migration patterns, but they differ in the timing of when they leave their winter grounds and the time they spend at their summer grounds. Averaging over all of this variation results in a relatively imprecise average estimate of the migration route (bottom row).




